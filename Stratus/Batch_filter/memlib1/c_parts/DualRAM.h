
///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2017 Cadence Design Systems, Inc. All rights reserved worldwide.
//
// The code contained herein is the proprietary and confidential information 
// of Cadence or its licensors, and is supplied subject to a previously 
// executed license and maintenance agreement between Cadence and customer. 
// This code is intended for use with Cadence high-level synthesis tools and 
// may not be used with other high-level synthesis tools. Permission is only 
// granted to distribute the code as indicated. Cadence grants permission for 
// customer to distribute a copy of this code to any partner to aid in designing 
// or verifying the customer's intellectual property, as long as such 
// distribution includes a restriction of no additional distributions from the 
// partner, unless the partner receives permission directly from Cadence.
//
// ALL CODE FURNISHED BY CADENCE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
// KIND, AND CADENCE SPECIFICALLY DISCLAIMS ANY WARRANTY OF NONINFRINGEMENT, 
// FITNESS FOR A PARTICULAR PURPOSE OR MERCHANTABILITY. CADENCE SHALL NOT BE 
// LIABLE FOR ANY COSTS OF PROCUREMENT OF SUBSTITUTES, LOSS OF PROFITS, 
// INTERRUPTION OF BUSINESS, OR FOR ANY OTHER SPECIAL, CONSEQUENTIAL OR 
// INCIDENTAL DAMAGES, HOWEVER CAUSED, WHETHER FOR BREACH OF WARRANTY, 
// CONTRACT, TORT, NEGLIGENCE, STRICT LIABILITY OR OTHERWISE.
//
////////////////////////////////////////////////////////////////////////////////


// Generated by bdw_memgen 19.27-s100
// Thu Apr 22 16:25:12 CEST 2021



#ifndef DualRAM_H
#define DualRAM_H

#include "systemc.h"
#include "stratus_hls.h"


#if !defined(STRATUS_VLG)
#include "cynw_comm_util.h"
#include "cynw_fifo.h"
#endif
#include "cynw_memory.h"
#if defined STRATUS  &&  ! defined CYN_DONT_SUPPRESS_MSGS
#pragma cyn_suppress_msgs NOTE
#pragma hls_ip_def NOTE
#endif	// STRATUS  &&  CYN_DONT_SUPPRESS_MSGS
#if !defined(STRATUS_VLG)
#endif


#if defined(STRATUS_VLG) || defined(STRATUS_HLS)
SC_MODULE(DualRAM)
#else
struct DualRAM
  : public sc_module,
    public cynw_memory_if< sc_uint<8>, sc_uint<3> >
#endif
    {
	HLS_EXTERNAL_MODULE;

   sc_in< bool > CLK;
   sc_in< bool > WE0;
   sc_in< sc_uint<3> > DIN0;
   sc_out< sc_uint<3> > DOUT0;
   sc_in< sc_uint<8> > A0;
   sc_out< sc_uint<3> > DOUT1;
   sc_in< sc_uint<8> > A1;
   sc_uint<3> mem[256];
 
 

#if defined(__GNUC__) && defined(BDW_DEBUG_MEMS)
    double m_last_read_time;
    double m_last_write_time;
    uint64 m_last_read_addr;
    uint64 m_last_write_addr;
    int m_num_errors;
#endif

#if defined(__GNUC__) 
    cynw_memory_if< sc_uint<8>, sc_uint<3> >* m_iface;

    void set_iface( cynw_memory_if< sc_uint<8>, sc_uint<3> >* iface ) {
        m_iface = iface;
    }
    void sync_get( uint64 a ) {
       if ( m_iface ) {
           mem[ a ] = m_iface->get( a );
       }
    }
    void sync_put( uint64 a ) {
       if ( m_iface ) {
           m_iface->put( a, mem[ a ] );
       }
    }
#endif
#ifdef STRATUS_HLS
   sc_uint<3> read0(sc_uint<8> A0, bool WE0=1);

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   sc_uint<3> write0(sc_uint<8> A0, sc_uint<3> DIN0, bool WE0=0);

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   void nop0(bool WE0=1);

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   sc_uint<3> read1(sc_uint<8> A1, bool WE1=1);

#endif	// STRATUS_HLS
#ifdef STRATUS_HLS
   void nop1();

#endif	// STRATUS_HLS
 
   void thread0();

   void thread1();

 
#if defined(STRATUS_VLG)
   SC_CTOR( DualRAM );

#else
   SC_HAS_PROCESS( DualRAM );

   DualRAM( sc_module_name name = sc_module_name(sc_gen_unique_name("DualRAM")));
#endif
   static const unsigned long implemented;
   static const unsigned long pipelined;
   static const float area;
   static const float delay;
   static const float setup_time;
   static const unsigned long latency_WE0;
   static const unsigned long latency_DIN0;
   static const unsigned long latency_A0;
   static const unsigned long bits_per_maskbit_WM0;
   static const unsigned long latency_A1;
   static const unsigned long bits_per_maskbit_WM1;
   static const unsigned long reg_mem_inputs;
   static const unsigned long reg_mem_outputs;
   static const unsigned long regs_at_mem_inputs;
   static const unsigned long regs_at_mem_outputs;
   static const unsigned long no_spec_reads;
   static const unsigned long is_mem;
   static const unsigned long clock_multiplier;
   static const bool has_extra_ports;
   static const bool is_prototype;
   static const char* naming_convention;


   typedef sc_uint<8>                       address_type;
   typedef sc_uint<3>                      data_type;
   
    enum {
        pipeline_depth = 1,
        mem_size = 256,
        SIZE = 256,
        address_width = 8,
        data_width = 3
    };


#if !defined(STRATUS_VLG) && !defined(STRATUS_HLS)
   // 
   // cynw_memory_if
   //
   data_type get( const address_type& address )
   {

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s: %s: read 0x%s from 0x%x\n", name(), sc_time_stamp().to_string().c_str(), mem[address.to_uint()].to_string(SC_HEX).c_str(), (int)address.to_uint());
#endif
        return mem[address.to_uint()];
   }
   void put( const address_type& address, const data_type& data )
   {

#if defined(__GNUC__) && defined(BDW_TRACE_MEMS)
        fprintf(stderr,"TRACE: %s%s: %s: write 0x%s to 0x%x\n", name(), "", sc_time_stamp().to_string().c_str(), data.to_string(SC_HEX).c_str(), (int)address.to_uint());
#endif
        mem[address.to_uint()] = data;
#if defined(__GNUC__)
            sync_put(address.to_uint());
#endif

}

#endif

#if defined(__GNUC__) && BDW_USE_SCV
    cynw_scv_memory_tx_stream< sc_uint<8>, sc_uint<3> >* m_p1_tx_stream;
    cynw_scv_memory_tx< sc_uint<8>, sc_uint<3> > m_p1_tx_0;
    cynw_scv_memory_tx_stream< sc_uint<8>, sc_uint<3> >* m_p2_tx_stream;
    cynw_scv_memory_tx< sc_uint<8>, sc_uint<3> > m_p2_tx_0;
#endif
};

#endif // DualRAM_H

